package org.continuity.wessbas.transform.jmeter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.OptionalInt;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.apache.jmeter.engine.TreeCloner;
import org.apache.jmeter.testelement.TestPlan;
import org.apache.jmeter.testelement.property.JMeterProperty;
import org.apache.jmeter.testelement.property.PropertyIterator;
import org.apache.jmeter.threads.ThreadGroup;
import org.apache.jorphan.collections.ListedHashTree;
import org.apache.jorphan.collections.SearchByClass;
import org.continuity.wessbas.managers.WessbasPipelineManager;

import net.voorn.markov4jmeter.control.ApplicationState;
import net.voorn.markov4jmeter.control.ApplicationStateTransition;
import net.voorn.markov4jmeter.control.BehaviorMix;
import net.voorn.markov4jmeter.control.BehaviorMixEntry;
import net.voorn.markov4jmeter.control.MarkovController;
import net.voorn.markov4jmeter.control.gui.MarkovControllerTreeListener;

/**
 * Splits the one ThreadGroup generated by WESSBAS into one per user group. This allows for
 * differently varying intensities per group.
 *
 * @author Henning Schulz
 *
 */
public class ThreadGroupSplitter {

	private final ListedHashTree testPlan;

	private final Map<String, String> intensitiesPerGroup;

	public ThreadGroupSplitter(ListedHashTree testPlan, Map<String, String> intensitiesPerGroup) {
		this.testPlan = testPlan;
		this.intensitiesPerGroup = intensitiesPerGroup;
	}

	public void doSplitting() {
		List<String> userGroups = extractUserGroups();
		ThreadGroup origThreadGroup = extractThreadGroup();

		moveConfigElementsToTest(origThreadGroup);

		for (String group : userGroups) {
			cloneThreadGroup(origThreadGroup, group);
		}

		testPlan.remove(origThreadGroup);
	}

	private List<String> extractUserGroups() {
		SearchByClass<MarkovController> search = new SearchByClass<>(MarkovController.class);
		testPlan.traverse(search);

		for (MarkovController mc : search.getSearchResults()) {
			BehaviorMix mix = mc.getBehaviorMix();

			return IntStream.range(0, mix.getBehaviorCount()).mapToObj(mix::getBehaviorEntry).map(e -> e.getProperty("Behavior.name").getStringValue()).collect(Collectors.toList());
		}

		throw new RuntimeException("Expected the test plan to contain a MarkovController!");
	}

	private ThreadGroup extractThreadGroup() {
		SearchByClass<ThreadGroup> search = new SearchByClass<>(ThreadGroup.class);
		testPlan.traverse(search);

		for (ThreadGroup threadGroup : search.getSearchResults()) {
			return threadGroup;
		}

		throw new RuntimeException("Expected the test plan to contain a ThreadGroup!");
	}

	private void moveConfigElementsToTest(ThreadGroup origThreadGroup) {
		SearchByClass<TestPlan> search = new SearchByClass<>(TestPlan.class);
		testPlan.traverse(search);
		TestPlan tp = null;

		for (TestPlan t : search.getSearchResults()) {
			tp = t;
			break;
		}

		if (tp == null) {
			throw new RuntimeException("Expected the test plan to contain a TestPlan!");
		}

		ListedHashTree subTree = (ListedHashTree) testPlan.getTree(origThreadGroup);
		List<Object> toBeRemoved = new ArrayList<>();

		for (Object element : subTree.list()) {
			if (!element.getClass().isAssignableFrom(MarkovController.class)) {
				toBeRemoved.add(element);
			}
		}

		for (Object element : toBeRemoved) {
			subTree.remove(element);
			testPlan.add(tp, element);
		}
	}

	private void cloneThreadGroup(ThreadGroup origThreadGroup, String group) {
		ThreadGroup clone = (ThreadGroup) origThreadGroup.clone();
		clone.setName(group);

		ListedHashTree subTree = (ListedHashTree) testPlan.getTree(origThreadGroup);
		TreeCloner cloner = new TreeCloner();
		subTree.traverse(cloner);
		ListedHashTree subTreeClone = cloner.getClonedTree();

		for (Object element : subTreeClone.list()) {
			if (element.getClass().isAssignableFrom(MarkovController.class)) {
				MarkovController mc = (MarkovController) element;
				mc.setName(group);
				MarkovControllerTreeListener.getInstance().registerController(mc);

				BehaviorMix mix = mc.getBehaviorMix();
				List<BehaviorMixEntry> entries = IntStream.range(0, mix.getBehaviorCount()).mapToObj(mix::getBehaviorEntry).collect(Collectors.toList());

				for (BehaviorMixEntry e : entries) {
					if (group.equals(e.getProperty("Behavior.name").getStringValue())) {
						adjustNumUsers(clone);
						e.setRFreq(1.0);
					} else {
						mix.removeBehaviorMix(e);
					}
				}
			}
		}

		updateStateIds(subTreeClone);
		testPlan.add(clone, subTreeClone);
	}

	private void adjustNumUsers(ThreadGroup threadGroup) {
		OptionalInt newNumUsers = Arrays.stream(intensitiesPerGroup.get(threadGroup.getName().substring(WessbasPipelineManager.PREFIX_BEHAVIOR_MODEL.length())).split(",")).mapToInt(Integer::parseInt)
				.max();
		threadGroup.setNumThreads(newNumUsers.orElse(threadGroup.getNumThreads()));
	}

	private void updateStateIds(ListedHashTree threadGroupTree) {
		SearchByClass<ApplicationState> stateSearch = new SearchByClass<>(ApplicationState.class);
		threadGroupTree.traverse(stateSearch);
		Map<Integer, Integer> newPerOld = new HashMap<>();

		for (ApplicationState state : stateSearch.getSearchResults()) {
			int oldId = state.getId();
			MarkovControllerTreeListener.getInstance().registerState(state);

			newPerOld.put(oldId, state.getId());
		}

		for (ApplicationState state : stateSearch.getSearchResults()) {
			PropertyIterator iter = state.getTransitions().getTransitions().iterator();

			while (iter.hasNext()) {
				JMeterProperty prop = iter.next();
				ApplicationStateTransition trans = (ApplicationStateTransition) prop.getObjectValue();

				int newId = newPerOld.get(trans.getDstStateId());
				prop.setName(Integer.toString(newId));
				trans.setDstStateId(newId);
			}
		}
	}

}
